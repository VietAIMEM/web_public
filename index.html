<!DOCTYPE html>
<html>
<head>
  <title>D·ª± ƒëo√°n c·ªï phi·∫øu</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f7fa;
      padding: 20px;
      text-align: center;
    }
    #ticker-select, #prediction-type {
      padding: 10px;
      font-size: 16px;
      width: 250px;
      margin-bottom: 20px;
      margin-right: 10px;
    }
    #result {
      margin: 20px auto;
      padding: 15px;
      background: white;
      border-radius: 10px;
      width: 360px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    canvas {
      margin-top: 20px;
      background: white;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      max-width: 100%;
    }
    .controls button {
      margin: 10px 5px;
      padding: 10px 20px;
      font-size: 14px;
      border: none;
      border-radius: 5px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    .controls button:hover {
      background-color: #0056b3;
    }
    .link {
      display: inline-block;
      margin: 10px 10px;
      padding: 5px 15px;
      background-color: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 5px;
    }
    .link:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <h2>D·ª± ƒëo√°n gi√° c·ªï phi·∫øu b·∫±ng LSTM</h2>
  <div>
    <span>B·∫°n c√≥ th·ªÉ qua d√πng:</span>
    <a href="" class="link">CNN</a>
    <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fprojectml-9dkmx7nuhfnvxbdhscfxme.streamlit.app%2F%3Ffbclid%3DIwZXh0bgNhZW0CMTAAYnJpZBExakJEaFJVbDhSSkpETngxWgEebwe-eOAA8TYc2-f8-ox27BKOwiUOtwAOJJQuegDliNdQi9AmzZ678Qw0OvA_aem_BWLWNTlSHYeL8gEfmTwUIw&h=AT1l4SOnbPSd-IfPP6hCHmy1oYvoWfp1kQtxnxNPq3SWs4QAPsF0kUmYrbuMrprVSKKygC8W7mxPHHJgecElJKtcXLlHienpLOeOXT33V5ypJ-mqVCX9-8D9kEmsKHxx88vt-A" class="link">PatchTST</a>
  </div>
  <input list="tickers-list" id="ticker-select" name="ticker-select" placeholder="Nh·∫≠p m√£ c·ªï phi·∫øu" />
  <datalist id="tickers-list"></datalist>
  <select id="prediction-type">
    <option value="next_minute">D·ª± ƒëo√°n ph√∫t ti·∫øp theo</option>
    <option value="two_minutes">D·ª± ƒëo√°n 2 ph√∫t ti·∫øp theo</option>
    <option value="3_minutes">D·ª± ƒëo√°n 3 ph√∫t ti·∫øp theo</option>
    <option value="4_minutes">D·ª± ƒëo√°n 4 ph√∫t ti·∫øp theo</option>
  </select>
  <div id="result"></div>
  <canvas id="stockChart"></canvas>

  <div class="controls">
    <button onclick="panChart(-1)">‚Üê Qua tr√°i</button>
    <button onclick="panChart(1)">‚Üí Qua ph·∫£i</button>
    <button onclick="resetZoom()">üîÑ Reset Zoom</button>
  </div>

  <script>
    const apiUrl = "http://127.0.0.1:8000";
    let stockChart;
    let currentHistoryData = [];
    let clickedPredictions = []; // L∆∞u tr·ªØ c√°c ƒëi·ªÉm d·ª± ƒëo√°n t·ª´ c√°c l·∫ßn nh·∫•p

    function createChart(labels, actualPrices, predictedPrices, predictionType) {
      const ctx = document.getElementById('stockChart').getContext('2d');
      if (stockChart) stockChart.destroy();

      let chartLabels = [...labels];
      let datasets = [
        {
          label: 'Gi√° th·ª±c t·∫ø',
          data: actualPrices,
          borderColor: '#007bff',
          backgroundColor: 'rgba(0, 123, 255, 0.1)',
          pointRadius: 3,
          pointHoverRadius: 6,
          tension: 0.3,
          fill: true
        }
      ];

      // Th√™m dataset cho c√°c ƒëi·ªÉm d·ª± ƒëo√°n t·ª´ c√°c l·∫ßn nh·∫•p
      if (clickedPredictions.length > 0) {
        let clickedData = Array(chartLabels.length).fill(null);
        clickedPredictions.forEach(pred => {
          const predTime = pred.time;
          const index = chartLabels.indexOf(predTime);
          if (index !== -1) {
            clickedData[index] = pred.price;
          }
        });
        datasets.push({
          label: 'ƒêi·ªÉm d·ª± ƒëo√°n t·ª´ nh·∫•p chu·ªôt',
          data: clickedData,
          borderColor: '#ff9900',
          backgroundColor: '#ff9900',
          pointRadius: 6,
          pointHoverRadius: 8,
          showLine: false, // Kh√¥ng n·ªëi c√°c ƒëi·ªÉm
          fill: false
        });
      }

      // Th√™m c√°c ƒëi·ªÉm d·ª± ƒëo√°n m·∫∑c ƒë·ªãnh (cho ƒëi·ªÉm cu·ªëi)
      if (predictionType === 'next_minute') {
        chartLabels.push(new Date(labels[labels.length - 1]).toISOString());
        datasets.push({
          label: 'Gi√° d·ª± ƒëo√°n ph√∫t 1',
          data: Array(actualPrices.length - 1).fill(null).concat([predictedPrices[0]]),
          borderColor: '#ff4d4f',
          borderDash: [5, 5],
          pointBackgroundColor: '#ff4d4f',
          pointRadius: 5,
          fill: false
        });
      } else if (predictionType === 'two_minutes') {
        const lastTime = new Date(labels[labels.length - 1]);
        chartLabels.push(new Date(lastTime.getTime() + 60 * 1000).toISOString());
        chartLabels.push(new Date(lastTime.getTime() + 120 * 1000).toISOString());
        datasets.push({
          label: 'Gi√° d·ª± ƒëo√°n ph√∫t 1',
          data: Array(actualPrices.length - 1).fill(null).concat([predictedPrices[0]]),
          borderColor: '#ff4d4f',
          borderDash: [5, 5],
          pointBackgroundColor: '#ff4d4f',
          pointRadius: 5,
          fill: false
        });
        datasets.push({
          label: 'Gi√° d·ª± ƒëo√°n ph√∫t 2',
          data: Array(actualPrices.length).fill(null).concat([predictedPrices[1]]),
          borderColor: '#00cc00',
          borderDash: [5, 5],
          pointBackgroundColor: '#00cc00',
          pointRadius: 5,
          fill: false
        });
      } else if (['3_minutes', '4_minutes'].includes(predictionType)) {
        const minutes = predictionType === '3_minutes' ? 3 : 4;
        const lastTime = new Date(labels[labels.length - 1]);
        for (let i = 1; i <= minutes; i++) {
          chartLabels.push(new Date(lastTime.getTime() + i * 60000).toISOString());
        }
        datasets.push({
          label: `Gi√° d·ª± ƒëo√°n ${minutes} ph√∫t`,
          data: Array(actualPrices.length - 1).fill(null).concat(predictedPrices),
          borderColor: '#ff4d4f',
          borderDash: [5, 5],
          pointBackgroundColor: '#ff4d4f',
          pointRadius: 5,
          fill: false
        });
      }

      stockChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: chartLabels,
          datasets: datasets
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: 'Bi·ªÉu ƒë·ªì gi√° c·ªï phi·∫øu (B·∫°n c√≥ th·ªÉ nh·∫•p v√†o c√°c ƒëi·ªÉm tr√™n bi·ªÉu ƒë·ªì ƒë·ªÉ d·ª± ƒëo√°n th·ªùi gian ƒë√≥)',
              font: { size: 18 }
            },
            tooltip: {
              mode: 'index',
              intersect: false
            },
            zoom: {
              pan: {
                enabled: true,
                mode: 'x'
              },
              zoom: {
                wheel: { enabled: true },
                pinch: { enabled: true },
                drag: { enabled: true, mode: 'x' },
                mode: 'x'
              }
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Th·ªùi gian'
              },
              ticks: {
                maxRotation: 45,
                minRotation: 20
              }
            },
            y: {
              title: {
                display: true,
                text: 'Gi√°'
              }
            }
          },
          onClick: (event, elements) => {
            if (elements.length > 0) {
              const index = elements[0].index;
              const datasetIndex = elements[0].datasetIndex;
              if (datasetIndex === 0 && index < labels.length) {
                const selectedTime = labels[index];
                const windowSize = predictionType === 'next_minute' ? 61 :
                                  predictionType === 'two_minutes' ? 62 :
                                  predictionType === '3_minutes' ? 63 : 64;
                const historySlice = currentHistoryData.slice(0, index + 1).slice(-windowSize);
                if (historySlice.length >= windowSize) {
                  const historyForPrediction = {
                    datetime: historySlice.map(h => h.datetime),
                    close: historySlice.map(h => h.close)
                  };
                  fetchPredictionForPoint(historyForPrediction, document.getElementById('ticker-select').value, predictionType, index, selectedTime);
                } else {
                  document.getElementById('result').innerHTML = `<p style="color:red;">Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ d·ª± ƒëo√°n t·∫°i ƒëi·ªÉm n√†y.</p>`;
                }
              }
            }
          }
        }
      });

      const zoomToLastPoints = (numPoints = 60) => {
        const xScale = stockChart.scales.x;
        const total = xScale.getLabels().length;
        if (total > numPoints) {
          const minLabel = xScale.getLabels()[total - numPoints];
          const maxLabel = xScale.getLabels()[total - 1];
          xScale.options.min = minLabel;
          xScale.options.max = maxLabel;
          stockChart.update();
        }
      };

      zoomToLastPoints(60);
    }

    function fetchPredictionForPoint(historyData, ticker, predictionType, clickedIndex, selectedTime) {
      fetch(`${apiUrl}/predict_custom/${ticker}?type=${predictionType}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          datetime: historyData.datetime,
          close: historyData.close
        })
      })
        .then(res => res.json())
        .then(data => {
          let resultHtml = `
            <h3>${data.ticker} (t·∫°i ${new Date(historyData.datetime[historyData.datetime.length - 1]).toLocaleString()})</h3>
            <p>D·ª± ƒëo√°n: <b>${data.predicted_price}</b></p>
            <p>Gi√° th·ª±c t·∫ø: ${data.actual_price}</p>
            <p>Ch√™nh l·ªách: ${data.error}</p>
          `;
          if (data.second_predicted_price) {
            resultHtml += `<p>Gi√° d·ª± ƒëo√°n ph√∫t 2: <b>${data.second_predicted_price}</b></p>`;
          }
          if (data.extended_predicted_prices) {
            resultHtml += `<p>Gi√° d·ª± ƒëo√°n cu·ªëi: <b>${data.extended_predicted_prices.at(-1)}</b></p>`;
          }
          document.getElementById("result").innerHTML = resultHtml;

          // Th√™m ƒëi·ªÉm d·ª± ƒëo√°n v√†o clickedPredictions t·∫°i th·ªùi gian c·ªßa ƒëi·ªÉm ƒë∆∞·ª£c nh·∫•p
          clickedPredictions = clickedPredictions.filter(pred => pred.time !== selectedTime); // X√≥a d·ª± ƒëo√°n c≈© t·∫°i c√πng th·ªùi gian
          if (predictionType === 'next_minute') {
            clickedPredictions.push({
              time: selectedTime,
              price: data.predicted_price
            });
          } else if (predictionType === 'two_minutes') {
            clickedPredictions.push({
              time: selectedTime,
              price: data.predicted_price
            });
            const nextTime = new Date(new Date(selectedTime).getTime() + 60 * 1000).toISOString();
            clickedPredictions.push({
              time: nextTime,
              price: data.second_predicted_price
            });
          } else if (['3_minutes', '4_minutes'].includes(predictionType)) {
            const minutes = predictionType === '3_minutes' ? 3 : 4;
            data.extended_predicted_prices.forEach((price, i) => {
              const predTime = new Date(new Date(selectedTime).getTime() + i * 60 * 1000).toISOString();
              clickedPredictions.push({
                time: predTime,
                price: price
              });
            });
          }

          // C·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì m√† kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn ƒëi·ªÉm d·ª± ƒëo√°n cu·ªëi
          const labels = currentHistoryData.map(h => h.datetime);
          const prices = currentHistoryData.map(h => h.close);
          const predictedPrices = data.extended_predicted_prices ? data.extended_predicted_prices : [data.predicted_price, data.second_predicted_price].filter(p => p !== undefined);
          createChart(labels, prices, predictedPrices, predictionType);
        })
        .catch(err => {
          document.getElementById("result").innerHTML = `<p style="color:red;">L·ªói khi d·ª± ƒëo√°n ƒëi·ªÉm: ${err.message}</p>`;
        });
    }

    function panChart(direction) {
      if (!stockChart) return;
      const panAmount = 200;
      stockChart.pan({ x: -direction * panAmount }, undefined, 'default');
    }

    function resetZoom() {
      if (!stockChart) return;
      stockChart.resetZoom();
    }

    fetch(`${apiUrl}/tickers`)
      .then(res => res.json())
      .then(data => {
        const input = document.getElementById("ticker-select");
        const datalist = document.getElementById("tickers-list");
        const predictionType = document.getElementById("prediction-type");

        data.tickers.forEach(t => {
          const option = document.createElement("option");
          option.value = t;
          datalist.appendChild(option);
        });

        function fetchPrediction() {
          const value = input.value.trim();
          const predType = predictionType.value;
          if (!value) return;

          // Reset clickedPredictions khi ch·ªçn ticker m·ªõi
          clickedPredictions = [];

          fetch(`${apiUrl}/predict/${value}?type=${predType}`)
            .then(res => res.json())
            .then(data => {
              let resultHtml = `
                <h3>${data.ticker}</h3>
                <p>D·ª± ƒëo√°n: <b>${data.predicted_price}</b></p>
                <p>Gi√° th·ª±c t·∫ø: ${data.actual_price}</p>
                <p>Ch√™nh l·ªách: ${data.error}</p>
              `;
              if (data.second_predicted_price) {
                resultHtml += `<p>Gi√° d·ª± ƒëo√°n ph√∫t 2: <b>${data.second_predicted_price}</b></p>`;
              }
              if (data.extended_predicted_prices) {
                resultHtml += `<p>Gi√° d·ª± ƒëo√°n cu·ªëi: <b>${data.extended_predicted_prices.at(-1)}</b></p>`;
              }

              document.getElementById("result").innerHTML = resultHtml;

              fetch(`${apiUrl}/history/${value}`)
                .then(res => res.json())
                .then(historyData => {
                  currentHistoryData = historyData.history;
                  const labels = historyData.history.map(h => h.datetime);
                  const prices = historyData.history.map(h => h.close);
                  const predictedPrices = data.extended_predicted_prices ? data.extended_predicted_prices : [data.predicted_price, data.second_predicted_price].filter(p => p !== undefined);
                  createChart(labels, prices, predictedPrices, predType);
                });
            })
            .catch(err => {
              document.getElementById("result").innerHTML = `<p style="color:red;">L·ªói khi l·∫•y d·ªØ li·ªáu.</p>`;
              if (stockChart) stockChart.destroy();
            });
        }

        input.addEventListener("change", fetchPrediction);
        predictionType.addEventListener("change", fetchPrediction);
      });
  </script>
</body>
</html>
