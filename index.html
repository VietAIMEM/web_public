<!DOCTYPE html>
<html>
<head>
  <title>D·ª± ƒëo√°n c·ªï phi·∫øu</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f7fa;
      padding: 20px;
      text-align: center;
    }
    #ticker-select, #prediction-type {
      padding: 10px;
      font-size: 16px;
      width: 250px;
      margin-bottom: 20px;
      margin-right: 10px;
    }
    #result {
      margin: 20px auto;
      padding: 15px;
      background: white;
      border-radius: 10px;
      width: 360px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    canvas {
      margin-top: 20px;
      background: white;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      max-width: 100%;
      
    }
    .controls button {
      margin: 10px 5px;
      padding: 10px 20px;
      font-size: 14px;
      border: none;
      border-radius: 5px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    .controls button:hover {
      background-color: #0056b3;
    }
    .link {
      display: inline-block;
      margin: 10px 10px;
      padding: 5px 15px;
      background-color: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 5px;
    }
    .link:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <h2>D·ª± ƒëo√°n gi√° c·ªï phi·∫øu b·∫±ng LSTM</h2>
  <div>
    <span>B·∫°n c√≥ th·ªÉ qua d√πng:</span>
    <a href="" class="link">CNN</a>
    <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fprojectml-9dkmx7nuhfnvxbdhscfxme.streamlit.app%2F%3Ffbclid%3DIwZXh0bgNhZW0CMTAAYnJpZBExakJEaFJVbDhSSkpETngxWgEebwe-eOAA8TYc2-f8-ox27BKOwiUOtwAOJJQuegDliNdQi9AmzZ678Qw0OvA_aem_BWLWNTlSHYeL8gEfmTwUIw&h=AT1l4SOnbPSd-IfPP6hCHmy1oYvoWfp1kQtxnxNPq3SWs4QAPsF0kUmYrbuMrprVSKKygC8W7mxPHHJgecElJKtcXLlHienpLOeOXT33V5ypJ-mqVCX9-8D9kEmsKHxx88vt-A" class="link">PatchTST</a>
  </div>
  <input list="tickers-list" id="ticker-select" name="ticker-select" placeholder="Nh·∫≠p m√£ c·ªï phi·∫øu" />
  <datalist id="tickers-list"></datalist>
  <select id="prediction-type">
    <option value="next_minute">D·ª± ƒëo√°n ph√∫t ti·∫øp theo</option>
    <option value="two_minutes">D·ª± ƒëo√°n 2 ph√∫t ti·∫øp theo</option>
    <option value="3_minutes">D·ª± ƒëo√°n 3 ph√∫t ti·∫øp theo</option>
    <option value="4_minutes">D·ª± ƒëo√°n 4 ph√∫t ti·∫øp theo</option>
  </select>
  <div id="result"></div>
  <canvas id="stockChart"></canvas>

  <!-- N√∫t ƒëi·ªÅu khi·ªÉn pan/zoom -->
  <div class="controls">
    <button onclick="panChart(-1)">‚Üê Qua tr√°i</button>
    <button onclick="panChart(1)">‚Üí Qua ph·∫£i</button>
    <button onclick="resetZoom()">üîÑ Reset Zoom</button>
  </div>

  <script>
    const apiUrl = "https://web-production-51b28.up.railway.app";
    let stockChart;

    function createChart(labels, actualPrices, predictedPrices, predictionType) {
      const ctx = document.getElementById('stockChart').getContext('2d');
      if (stockChart) stockChart.destroy();

      let chartLabels = [...labels];
      let datasets = [
        {
          label: 'Gi√° th·ª±c t·∫ø',
          data: actualPrices,
          borderColor: '#007bff',
          backgroundColor: 'rgba(0, 123, 255, 0.1)',
          pointRadius: 3,
          pointHoverRadius: 6,
          tension: 0.3,
          fill: true
        }
      ];

      if (predictionType === 'next_minute') {
        chartLabels.push(new Date(labels[labels.length - 1]).toISOString());
        datasets.push({
          label: 'Gi√° d·ª± ƒëo√°n ph√∫t 1',
          data: Array(actualPrices.length - 1).fill(null).concat([predictedPrices[0]]),
          borderColor: '#ff4d4f',
          borderDash: [5, 5],
          pointBackgroundColor: '#ff4d4f',
          pointRadius: 5,
          fill: false
        });
      } else if (predictionType === 'two_minutes') {
        const lastTime = new Date(labels[labels.length - 1]);
        chartLabels.push(new Date(lastTime.getTime() + 60 * 1000).toISOString());
        chartLabels.push(new Date(lastTime.getTime() + 120 * 1000).toISOString());
        datasets.push({
          label: 'Gi√° d·ª± ƒëo√°n ph√∫t 1',
          data: Array(actualPrices.length - 1).fill(null).concat([predictedPrices[0]]),
          borderColor: '#ff4d4f',
          borderDash: [5, 5],
          pointBackgroundColor: '#ff4d4f',
          pointRadius: 5,
          fill: false
        });
        datasets.push({
          label: 'Gi√° d·ª± ƒëo√°n ph√∫t 2',
          data: Array(actualPrices.length).fill(null).concat([predictedPrices[1]]),
          borderColor: '#00cc00',
          borderDash: [5, 5],
          pointBackgroundColor: '#00cc00',
          pointRadius: 5,
          fill: false
        });
      } else if (['3_minutes', '4_minutes'].includes(predictionType)) {
        const minutes = predictionType === '3_minutes' ? 3 : 4;
        const lastTime = new Date(labels[labels.length - 1]);
        for (let i = 1; i <= minutes; i++) {
          chartLabels.push(new Date(lastTime.getTime() + i * 60000).toISOString());
        }
        datasets.push({
          label: `Gi√° d·ª± ƒëo√°n ${minutes} ph√∫t`,
          data: Array(actualPrices.length - 1).fill(null).concat(predictedPrices),
          borderColor: '#ff4d4f',
          borderDash: [5, 5],
          pointBackgroundColor: '#ff4d4f',
          pointRadius: 5,
          fill: false
        });
      }

      stockChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: chartLabels,
          datasets: datasets
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: 'Bi·ªÉu ƒë·ªì gi√° c·ªï phi·∫øu',
              font: { size: 18 }
            },
            tooltip: {
              mode: 'index',
              intersect: false
            },
            zoom: {
              pan: {
                enabled: true,
                mode: 'x'
              },
              zoom: {
                wheel: { enabled: true },
                pinch: { enabled: true },
                drag: { enabled: true, mode: 'x' },
                mode: 'x'
              }
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Th·ªùi gian'
              },
              ticks: {
                maxRotation: 45,
                minRotation: 20
              }
            },
            y: {
              title: {
                display: true,
                text: 'Gi√°'
              }
            }
          }
        }
      });

      // ‚úÖ Zoom m·∫∑c ƒë·ªãnh v√†o 60 ƒëi·ªÉm cu·ªëi
      const zoomToLastPoints = (numPoints = 60) => {
        const xScale = stockChart.scales.x;
        const total = xScale.getLabels().length;
        if (total > numPoints) {
          const minLabel = xScale.getLabels()[total - numPoints];
          const maxLabel = xScale.getLabels()[total - 1];
          xScale.options.min = minLabel;
          xScale.options.max = maxLabel;
          stockChart.update();
        }
      };

      zoomToLastPoints(60);
    }

    // ‚úÖ ƒêi·ªÅu khi·ªÉn Pan tr√°i/ph·∫£i
    function panChart(direction) {
      if (!stockChart) return;
      const panAmount = 200; // Pan 200px
      stockChart.pan({ x: -direction * panAmount }, undefined, 'default');
    }

    function resetZoom() {
      if (!stockChart) return;
      stockChart.resetZoom();
    }

    // ‚úÖ L·∫•y danh s√°ch ticker & d·ª± ƒëo√°n
    fetch(`${apiUrl}/tickers`)
      .then(res => res.json())
      .then(data => {
        const input = document.getElementById("ticker-select");
        const datalist = document.getElementById("tickers-list");
        const predictionType = document.getElementById("prediction-type");

        data.tickers.forEach(t => {
          const option = document.createElement("option");
          option.value = t;
          datalist.appendChild(option);
        });

        function fetchPrediction() {
          const value = input.value.trim();
          const predType = predictionType.value;
          if (!value) return;

          fetch(`${apiUrl}/predict/${value}?type=${predType}`)
            .then(res => res.json())
            .then(data => {
              let resultHtml = `
                <h3>${data.ticker}</h3>
                <p>D·ª± ƒëo√°n: <b>${data.predicted_price}</b></p>
                <p>Gi√° th·ª±c t·∫ø: ${data.actual_price}</p>
                <p>Ch√™nh l·ªách: ${data.error}</p>
              `;
              if (data.second_predicted_price) {
                resultHtml += `<p>Gi√° d·ª± ƒëo√°n ph√∫t 2: <b>${data.second_predicted_price}</b></p>`;
              }
              if (data.extended_predicted_prices) {
                resultHtml += `<p>Gi√° d·ª± ƒëo√°n cu·ªëi: <b>${data.extended_predicted_prices.at(-1)}</b></p>`;
              }

              document.getElementById("result").innerHTML = resultHtml;

              fetch(`${apiUrl}/history/${value}`)
                .then(res => res.json())
                .then(historyData => {
                  const labels = historyData.history.map(h => h.datetime);
                  const prices = historyData.history.map(h => h.close);
                  const predictedPrices = data.extended_predicted_prices ? data.extended_predicted_prices : [data.predicted_price, data.second_predicted_price].filter(p => p !== undefined);
                  createChart(labels, prices, predictedPrices, predType);
                });
            })
            .catch(err => {
              document.getElementById("result").innerHTML = `<p style="color:red;">L·ªói khi l·∫•y d·ªØ li·ªáu.</p>`;
              if (stockChart) stockChart.destroy();
            });
        }

        input.addEventListener("change", fetchPrediction);
        predictionType.addEventListener("change", fetchPrediction);
      });
  </script>
</body>
</html>
